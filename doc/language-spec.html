<html>
  <head>

    <title>Liquor 2.0 Language Specification</title>
    <meta name="generator" content="kramdown 0.13.7" />
  </head>
  <body>
  <style>
body {
  margin: 0 auto;
  color: #444444;
  line-height: 1;
  max-width: 960px;
  padding: 30px;
}
h1, h2, h3, h4 {
  color: #111111;
  font-weight: 400;
}
h1, h2, h3, h4, h5 {
  margin-bottom: 24px;
  padding: 0;
}
h1 {
  font-size: 48px;
}
h2 {
  font-size: 36px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 21px;
}
h5 {
  font-size: 18px;
}
a {
  color: #0099ff;
  margin: 0;
  padding: 0;
  vertical-align: baseline;
}
a:visited {
  color: #0047ff;
}
a:hover {
  text-decoration: none;
  color: #ff6600;
}
li {
  line-height: 24px;
}
p, ul, ol {
  font-size: 16px;
  line-height: 24px;
  max-width: 740px;
  margin-bottom: 14px;
}
pre {
  padding: 0px 24px;
  max-width: 800px;
  white-space: pre-wrap;
}
code {
  line-height: 1.5;
  font-size: 13px;
  background: #E9E8E7;
  border: 1px solid #E0DDDA;
  border-radius: 0.2em;
  padding: 1px;
}
pre > code {
  border: none;
  background: none;
}
#markdown-toc, #markdown-toc ul {
  list-style-type: none;
  margin: 0 0 0 1em;
  padding: 0;
}
#markdown-toc {
  margin: 20px 0 0 0;
}
code, dd {
  font-family: Consolas, Monaco, Andale Mono, monospace;
}
body, em {
  font-family: Georgia, Palatino, serif;
}
dl {
  font-size: 16px;
  line-height: 24px;
}
dt {
  font-style: italic;
  margin-top: 10px;
}
dt:after {
  font-style: normal;
  padding-left: 0.5em;
  content: '::';
}
dt em {

}
</style>

<h1 id="liquor-20-language-specification">Liquor 2.0 Language Specification</h1>

<p style="text-align: right"><em>This version of specification is a working draft.</em></p>

<h2 id="table-of-contents">Table of Contents</h2>

<ul id="markdown-toc">
  <li><a href="#liquor-20-language-specification">Liquor 2.0 Language Specification</a>    <ul>
      <li><a href="#table-of-contents">Table of Contents</a></li>
      <li><a href="#preface">1 Preface</a></li>
      <li><a href="#overview">2 Overview</a>        <ul>
          <li><a href="#introduction">2.1 Introduction</a></li>
          <li><a href="#types-and-variables">2.2 Types and Variables</a></li>
          <li><a href="#type-conversion">2.3 Type Conversion</a></li>
          <li><a href="#expressions">2.4 Expressions</a>            <ul>
              <li><a href="#literals">2.4.1 Literals</a></li>
              <li><a href="#operators">2.4.2 Operators</a>                <ul>
                  <li><a href="#arithmetic-operators">2.4.2.1 Arithmetic Operators</a></li>
                  <li><a href="#boolean-operators">2.4.2.2 Boolean Operators</a></li>
                  <li><a href="#comparison-operators">2.4.2.3 Comparison Operators</a></li>
                  <li><a href="#indexing-operator">2.4.2.4 Indexing Operator</a></li>
                  <li><a href="#access-operator">2.4.2.5 Access Operator</a></li>
                </ul>
              </li>
              <li><a href="#function-calls">2.4.3 Function Calls</a></li>
              <li><a href="#variable-access">2.4.4 Variable Access</a></li>
              <li><a href="#filter-expressions">2.4.5 Filter Expressions</a></li>
            </ul>
          </li>
          <li><a href="#blocks">2.5 Blocks</a></li>
          <li><a href="#interpolations">2.6 Interpolations</a></li>
          <li><a href="#tags">2.7 Tags</a></li>
        </ul>
      </li>
      <li><a href="#grammar">3 Grammar</a>        <ul>
          <li><a href="#syntax">3.1 Syntax</a></li>
          <li><a href="#expressions-1">3.2 Expressions</a></li>
        </ul>
      </li>
      <li><a href="#compile-time-behavior">4 Compile-time Behavior</a></li>
      <li><a href="#runtime-behavior">5 Runtime Behavior</a></li>
      <li><a href="#builtins">6 Builtins</a></li>
    </ul>
  </li>
</ul>

<h2 id="preface">1 Preface</h2>

<p>Liquor 2.0 language is developed with several goals in mind.</p>

<ul>
  <li>First, it should be secure. There must not be a way to bypass sandbox restrictions.</li>
  <li>Second, it should not necessarily be compatible with Liquor 1.0, but should not have vastly different syntax. Liquor 1.0 syntax is easy to understand by frontend developers, and it should remain so.</li>
  <li>Third, it should be as much statically verifiable as it is rationally possible. The amount of errors which can be detected only at runtime should be minimal. This will also lead to efficient implementations.</li>
  <li>Fourth, it should be elegant and minimalistic.</li>
</ul>

<p>This specification is primarily targeted at language implementors.</p>

<h2 id="overview">2 Overview</h2>

<h3 id="introduction">2.1 Introduction</h3>

<p>Liquor 2.0 language is a templating language for text-based content, e.g. HTML pages. As Liquor is a templating language, it is useless without extension with domain-specific features from a host environment; it is similar to <a href="http://www.lua.org/">Lua</a> in this aspect.</p>

<p>Liquor is meant to be statically compiled to another language for efficiency, typically to the one the host environment is executed in. It also provides sandbox restrictions, which allow Liquor code to invoke certain methods on the host objects, but only ones explicitly marked as scriptable.</p>

<p>Liquor is a statically scoped, weakly and dynamically typed imperative language with lazily evaluated expressions. As it is essentially a domain-specific language for string concatenation, it has an unusual syntax where code is embedded in a text stream, and a final result of executing a Liquor program is always a string. All language constructs are similarly centered around string manipulation.</p>

<p>Liquor has four basic elements: <em>blocks</em>, <em>tags</em>, <em>interpolations</em> and <em>expressions</em>. All four of these elements can be <em>executed</em> and return a value. <em>Blocks</em>, <em>tags</em> and <em>interpolations</em> always return a string value.</p>

<p>Liquor does not have non-local control flow constructs by itself, such as exceptions and function definitions. This was done intentionally in order to simplify the language.</p>

<p>Liquor has distinct compile-time and runtime error checking. There are no fatal runtime errors, i.e. a Liquor program always evaluates to some value.</p>

<h3 id="types-and-variables">2.2 Types and Variables</h3>

<p>Liquor has the following basic types: <strong>Null</strong>, <strong>Boolean</strong>, <strong>Integer</strong>, <strong>String</strong>, <strong>Tuple</strong> and <strong>External</strong>. A value of every type except <strong>External</strong> can be created from within a Liquor program. Values of type <strong>External</strong> can only be returned by the host environment.</p>

<p>All Liquor values are immutable; once created, a value cannot change.</p>

<p>There is exactly one value of type <strong>Null</strong>, and it is called <em>null</em>.</p>

<p>There are exactly two values of type <strong>Boolean</strong>, and they are called <em>true</em> and <em>false</em>.</p>

<p>The only values considered “falseful” in a conditional context are <em>null</em> and <em>false</em>. Every other value, including <strong>Integer</strong> 0 (zero), is considered “truthful”.</p>

<p>Type <strong>Integer</strong> denotes an integer value of unspecified size. Implementation may impose additional restrictions on the representable range of <strong>Integer</strong> type.</p>

<p>Type <strong>String</strong> denotes a sequence of <a href="http://unicode.org/">Unicode</a> codepoints. Note that codepoints are not the same as characters or graphemes; there may exist an implementation-specific way of handling composite characters. See also the relevant <a href="http://www.unicode.org/faq/char_combmark.html">Unicode FAQ entry</a>.</p>

<p>Type <strong>Tuple</strong> denotes a heteromorphic sequence of values.</p>

<p>Type <strong>External</strong> denotes an object belonging to the host environment.</p>

<h3 id="type-conversion">2.3 Type Conversion</h3>

<p>Liquor supports exactly one implicit type conversion. In any context where a <strong>String</strong> value is expected, an <strong>Integer</strong> value can be provided. The <strong>Integer</strong> value will then be converted to a corresponding decimal ASCII representation without any leading zeroes.</p>

<h3 id="expressions">2.4 Expressions</h3>

<p>Liquor has <em>expressions</em>, which can be used to perform computations with values. This section does not define a normative grammar; the full grammar is provided in section <a href="#grammar">Grammar</a>.</p>

<p>Order of evaluation of Liquor expressions is not defined. As every value is immutable, the value of the entire expression should not depend upon the order of evaluation. Implementation-provided tags and functions should not mutate any global state.</p>

<h4 id="literals">2.4.1 Literals</h4>

<p>All Liquor types except <strong>External</strong> can be specified as literals in expressions.</p>

<p>Identifiers <em>null</em>, <em>true</em> and <em>false</em> evaluate to the corresponding values.</p>

<p>Numeric literals evaluate to a corresponding <strong>Integer</strong> value, and always use base 10. Numeric literals can be specified with any amount of leading zeroes. There are no negative numeric literals.</p>

<p>String literals evaluate to a corresponding <strong>String</strong> value. String literals can be equivalently specified with single or double quotes. Strings support escaping with backslash, and there are exactly two escape sequences: one inserts a literal backslash, and the other one inserts a literal quote. More specifically, single quoted string supports escape sequences <code>\\</code> and <code>\'</code>, and double quoted string supports escape sequences <code>\\</code> and <code>\"</code>. A single backslash followed by any character not specified above is translated to a literal backslash.</p>

<p>Tuple literals evaluate to a corresponding <strong>Tuple</strong> value. Tuple literals are surrounded by square brackets and delimited with commas; that is, <code>[ 1, 2, 3 ]</code> is a tuple literal containing three integer values, one, two and three, in that exact order.</p>

<h4 id="operators">2.4.2 Operators</h4>

<p>Liquor supports unary and binary infix operators in expressions. All operators are left-associative.</p>

<p>Liquor operators are listed in order of precedence, from highest to lowest, by the following table:</p>

<ol>
  <li><code>[]</code>, <code>.</code></li>
  <li>unary <code>-</code>, <code>!</code></li>
  <li><code>*</code>, <code>/</code>, <code>%</code></li>
  <li><code>+</code>, binary <code>-</code></li>
  <li><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
  <li><code>&amp;&amp;</code></li>
  <li><code>||</code></li>
</ol>

<p>The following operators are infix and binary: <code>*</code>, <code>/</code>, <code>%</code>, <code>+</code>, <code>-</code>, <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&amp;&amp;</code>, <code>||</code>.
The following operators are infix and unary: <code>-</code>, <code>!</code>.</p>

<p>The indexing operator <code>[]</code> is binary but not infix. The access operator <code>.</code> is binary but only interprets its right-hand side argument lexically (i.e. does not evaluate it).</p>

<h5 id="arithmetic-operators">2.4.2.1 Arithmetic Operators</h5>

<p>Arithmetic operators are <code>*</code> (multiply), <code>/</code> (division), <code>%</code> (modulo), <code>+</code> (plus) and <code>-</code> (minus; binary and unary).</p>

<p>All arithmetic operators, whether unary or binary, require every argument to be of type <strong>Integer</strong>. If this is not the case, a runtime error condition is signaled.</p>

<p>If the result of an arithmetic operation exceeds the range an implementation can represent, the behavior is implementation-defined.</p>

<h5 id="boolean-operators">2.4.2.2 Boolean Operators</h5>

<p>Boolean operators are <code>!</code> (not; unary), <code>&amp;&amp;</code> (and) and <code>||</code> (or).</p>

<p>All boolean operators, whether unary or binary, convert each argument to type <strong>Boolean</strong> prior to evaluation. The rules of conversion are:</p>

<ol>
  <li>If the value equals <em>null</em> or <em>false</em>, it is assumed to be <em>false</em>.</li>
  <li>Else, the value is assumed to be <em>true</em>.</li>
</ol>

<p>All boolean operators return a value of type <strong>Boolean</strong>. Binary boolean operators do not provide any guarantees on order or sequence of evaluation.</p>

<h5 id="comparison-operators">2.4.2.3 Comparison Operators</h5>

<p>Comparison operators are <code>==</code> (equals), <code>!=</code> (not equals), <code>&lt;</code> (less), <code>&lt;=</code> (less or equal), <code>&gt;</code> (greater) and <code>&gt;=</code> (greater or equal).</p>

<p>Operators <code>==</code> and <code>!=</code> compare values by equality, not identity. Thus, the expression <code>[ 1, 2 ] == [ 1, 2 ]</code> evluates to <em>true</em>. These operators never signal an error condition or implicitly convert types.</p>

<p>Operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> require both arguments to be of type <strong>Integer</strong>. If this is not the case, a runtime error condition is signaled. Otherwise, a corresponding value of type <strong>Boolean</strong> is returned.</p>

<h5 id="indexing-operator">2.4.2.4 Indexing Operator</h5>

<p>Indexing operator is <code>[]</code>.</p>

<p>Indexing operator requires its left-hand side argument to be of type <strong>Tuple</strong>, and right-hand side argument to be of type <strong>Integer</strong>. If this is not the case, a runtime error condition is signaled.</p>

<p>Indexing operator of form <code><em>t</em>[<em>n</em>]</code> evaluates to <em>n</em>-th value from tuple <em>t</em> with zero-based indexing. If <code>n</code> is negative, then <em>n</em>+1-th element from the end of tuple is returned. For example, <code><em>t</em>[-1]</code> will evaluate to the last element of the tuple <em>t</em>.</p>

<p>If the requested element does not exist in the tuple, the indexing operator evaluates to <em>null</em>.</p>

<h5 id="access-operator">2.4.2.5 Access Operator</h5>

<p>Access operator is <code>.</code>.</p>

<p>Access operator requires its left-hand side argument to be of type <strong>External</strong>, and right-hand side argument to be a lexical identifier. If this is not the case, a runtime error condition is signaled.</p>

<p>Access operator of form <code><em>e</em>.<em>f</em></code> evaluates to the value of field <em>f</em> of external object <em>e</em>. This evaluation is done in an implementation-defined way. Access operator can evaluate to any type.</p>

<p>If the requested field does not exist in the external object, a runtime error condition is signaled.</p>

<h4 id="function-calls">2.4.3 Function Calls</h4>

<p>Identifiers can be bound to functions prior to compilation. Identifiers <em>null</em>, <em>true</em> and <em>false</em> cannot be bound to a function.</p>

<p>Functions are defined in an implementation-specific way. Functions can have zero to one unnamed formal parameters and any amount of named formal parameters. If an unnamed formal parameter exists, it is mandatory. Named formal parameters can be either mandatory or optional. Absence of a mandatory formal parameter will result in a compile-time error. Named formal parameter order is irrelevant.</p>

<p>Function calls have mandatory parentheses, and arguments are whitespace-delimited.</p>

<p>If a function call includes two named parameters with the same name, a compile-time error is raised.</p>

<p>If a hypothetical function <em>substr</em> has one unnamed formal parameter and two optional named formal parameters <em>from</em> and <em>length</em>, then all of the following expressions are syntactically valid and will not result in a compile-time error: <code>substr("foobar")</code>, <code>substr("foobar" from: 1)</code>, <code>substr("foobar" from: 1 length:(5 - 2))</code>. The following expression, however, is syntactically valid but will result in a compile-time error: <code>substr(from: 1)</code>.</p>

<h4 id="variable-access">2.4.4 Variable Access</h4>

<p>Every identifier except <em>null</em>, <em>true</em> and <em>false</em> which is not bound to a function name is available to be bound as a variable name. Such identifier would evaluate to a value of the variable.</p>

<p>Variable definition and scoping will be further discussed in section <a href="#tags">Tags</a>.</p>

<p>Referencing an undefined variable shall result in a compile-time error.</p>

<h4 id="filter-expressions">2.4.5 Filter Expressions</h4>

<p>Filter expressions are a syntactic sugar for method composition and currying.</p>

<p>
In essence, <code><em>e</em> | <em>f</em> a: 1 | <em>g</em></code> is equivalent to <code><em>g</em>(<em>f</em>(<em>e</em>() a: 1))</code>.
</p>

<h3 id="blocks">2.5 Blocks</h3>

<p>A block is a chunk of plaintext with <em>tags</em> and <em>interpolations</em> embedded into it. Every Liquor program has at least one block: the toplevel one.</p>

<p>A block consisting only of plaintext would return its literal value upon execution. Thus, the famous Hello World program would be as follows:</p>

<pre><code>Hello World!
</code></pre>

<p>This program would evaluate to a string <code>Hello World!</code>.</p>

<p>A block can have other elements embedded into it. When such a block is executed, these elements are executed in syntactical order and are replaced with the value returned by the element.</p>

<h3 id="interpolations">2.6 Interpolations</h3>

<p>An interpolation is a syntactic construct of form <code>{{ expr }}</code> which can be embedded in a block. The expression <code>expr</code> should evaluate to a value of type <strong>String</strong>; an <a href="#type-conversion">implicit conversion</a> might take place. If this is not the case, a runtime error condition is signaled.</p>

<p>An example of using an interpolation would be:</p>

<pre><code>The sum of two and three is: {{ 2 + 3 }}
</code></pre>

<p>This program would evaluate to a string <code>The sum of two and three is: 5</code>.</p>

<h3 id="tags">2.7 Tags</h3>

<p>A tag is a syntactic construct of form <code>{% tag expr kw: arg do: %} ... {% endtag %}</code>. A tag has a syntax similar to a function call, but it can receive blocks of code as argument values and lazily evaluate passed expressions and blocks of code.</p>

<p>Tags are defined in an implementation-specific way. Tags can have zero to one unnamed formal parameters and any amount of named formal parameters. If an unnamed formal parameter exists, it is mandatory. Named formal parameters can be either mandatory or optional. Absence of a mandatory formal parameter will result in a compile-time error.</p>

<p>Tags have full control upon parameter evaluation. Tags can require arguments to be of a certain lexical form, e.g. a <code>for</code> tag could require its unnamed formal parameter to be a lexical identifier.</p>

<p>To pass a block of code to a tag, the closing tag delimiter should immediately follow a parameter name. Everything from the closing tag delimiter to the matching opening tag delimiter should be parsed as a block and passed as a value of the corresponding parameter. After the matching opening tag delimiter, the parameter list is continued.</p>

<p>If a tag <code><em>t</em></code> does not include any embedded blocks, it ends after a first matching closing tag delimiter. Otherwise, the tag ends after a first matching construct of the form <code>{% end<em>t</em> %}</code>.</p>

<p>Unlike functions, tags can receive multiple named parameters with the same name. Tag named parameters are a syntactic tool and should be thoroughly verified by the tag implementation. Incorrect names or order of named parameters should result in a compile-time error.</p>

<p>All of the following are examples of syntactically valid tags:</p>

<pre><code>{% yield %}

{% if var &gt; 10 do: %}
  Var is greater than 10.
{% endif %}

{% for i in: [ 1, 2, 3 ] do: %}
  Value: {{ i }}
{% endfor %}

{% if length(params.test) == 1 then: %}
  Test has length 1.
{% elsif: length(params.test) == 2 then: %}
  Test has length 2.
{% else: %}
  Test has unidentified length.
{% endif %}

{% capture "buffer" %}
  This text will be printed twice.
{% endcapture %}
{% yield from: "buffer" %}
{% yield from: "buffer" %}
</code></pre>

<h2 id="grammar">3 Grammar</h2>

<p>The following Extended Backus-Naur form grammar is normative. The native character set of Liquor is Unicode, and every character literal specified is an explicit codepoint or continuous codepoint set.</p>

<h3 id="syntax">3.1 Syntax</h3>

<dl>
  <dt>Whitespace</dt>
  <dd>( <strong>U+0007</strong> | <strong>U+0020</strong> )+</dd>
  <dt>Alpha</dt>
  <dd><strong>a</strong> to <strong>z</strong> | <strong>A</strong> to <strong>Z</strong></dd>
  <dt>Digit</dt>
  <dd><strong>0</strong> to <strong>9</strong></dd>
  <dt>Any</dt>
  <dd>any Unicode character</dd>
  <dt>Symbol</dt>
  <dd><em>Alpha</em> | <strong>_</strong></dd>
  <dt>Identifier</dt>
  <dd><em>Symbol</em> ( <em>Symbol</em> | <em>Digit</em> )*</dd>
  <dt>IntegerLiteral</dt>
  <dd><em>Digit</em>+</dd>
  <dt>StringLiteral</dt>
  <dd><strong>"</strong> ( <strong>\\</strong>  | <strong>\"</strong> | <em>Any</em> not <strong>"</strong> )* <strong>"</strong></dd>
  <dd><strong>'</strong> ( <strong>\\</strong>  | <strong>\'</strong> | <em>Any</em> not <strong>'</strong> )* <strong>'</strong></dd>
  <dt>TupleLiteral</dt>
  <dd><strong>[</strong> <em>TupleLiteralContent</em> <strong>]</strong></dd>
  <dt>TupleLiteralContent</dt>
  <dd>empty</dd>
  <dd><em>Expression</em> <strong>,</strong> <em>TupleLiteralContent</em></dd>
  <dd><em>Expression</em></dd>
</dl>

<h3 id="expressions-1">3.2 Expressions</h3>

<dl>
  <dt>PrimaryExpression</dt>
  <dd><em>Identifier</em></dd>
  <dd><strong>(</strong> <em>Expression</em> <strong>)</strong></dd>
  <dt>Expression</dt>
  <dd><em>IntegerLiteral</em></dd>
  <dd><em>StringLiteral</em></dd>
  <dd><em>TupleLiteral</em></dd>
  <dd><em>Identifier</em> <strong>(</strong> <em>Arguments</em> <strong>)</strong></dd>
  <dd><em>PrimaryExpression</em> <strong>[</strong> <em>Expression</em> <strong>]</strong></dd>
  <dd><em>PrimaryExpression</em> <strong>.</strong> <em>Identifier</em></dd>
  <dd><strong>-</strong> <em>Expression</em></dd>
  <dd><strong>!</strong> <em>Expression</em></dd>
  <dd>TODO</dd>
</dl>

<h2 id="compile-time-behavior">4 Compile-time Behavior</h2>

<p>TODO</p>

<h2 id="runtime-behavior">5 Runtime Behavior</h2>

<p>TODO</p>

<h2 id="builtins">6 Builtins</h2>


  </body>
</html>
